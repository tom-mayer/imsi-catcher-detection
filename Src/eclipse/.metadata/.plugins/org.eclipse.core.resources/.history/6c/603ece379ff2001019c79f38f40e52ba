from pyCatcherModel import BaseStationInformation
import subprocess
import threading 
import re
from pyCatcherSettings import Commands
import sys
import time
import gtk #@UnresolvedImport

class DriverConnector:        
    def __init__ (self):
        self._scan_thread_break = False
        self._firmware_thread_break = False
        self._firmware_waiting_callback = None
        self._firmware_loaded_callback = None
        self._base_station_found_callback = None
        self._firmThread = None
        self._scanThread = None
        
    def start_scanning (self, base_station_found_callback):
        self._scan_thread_break = False
        self._base_station_found_callback = base_station_found_callback
        self._scanThread = ScanThread(self._base_station_found_callback, self._scan_thread_break)
        self._scanThread.start()

    def start_firmware(self, firmware_waiting_callback, firmware_loaded_callback):
        self._firmware_thread_break = False
        self._firmware_waiting_callback = firmware_waiting_callback
        self._firmware_loaded_callback = firmware_loaded_callback      
        self._firmThread = FirmwareThread(self._firmware_waiting_callback, self._firmware_loaded_callback, self._firmware_thread_break)
        self._firmThread.start()
        
    def stop_scanning (self):
        self._scan_thread_break = True
        
    def stop_firmware(self):
        self._firmware_thread_break = True
        
    def shutdown(self):
        if self._firmThread:
            self._firmThread.join(10)
        if self._scanThread:
            self._scanThread.join(10)
        
class FirmwareThread(threading.Thread):
    def __init__(self, firmware_waiting_callback, firmware_loaded_callback, thread_break):
        gtk.gdk.threads_init()
        threading.Thread.__init__(self)
        self._firmware_waiting_callback = firmware_waiting_callback
        self._firmware_loaded_callback = firmware_loaded_callback
        self._thread_break = thread_break
       
    def run(self):
        loader_process_object = subprocess.Popen(Commands['osmocon_command'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        time.sleep(3)
        self._firmware_waiting_callback()
        while not self._thread_break:
            line = loader_process_object.stdout.readline()
            #if line:
            #    print line
            if line.strip() == 'Finishing download phase':
                self._firmware_loaded_callback()
            #time.sleep(0.5)
        print 'killing firmware'
        loader_process_object.kill()

class ScanThread(threading.Thread):
        def __init__(self, base_station_found_callback, thread_break):
            gtk.gdk.threads_init()
            threading.Thread.__init__(self)
            self._base_station_found_callback = base_station_found_callback
            self._thread_break = thread_break
        
        def run(self): 
            scan_process = subprocess.Popen(Commands['scan_command'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            time.sleep(2)
            while not self._thread_break:
                line = scan_process.stdout.readline()
                if line:
                    #print line
                    #sys.stdout.flush()
                    if re.search('SysInfo', line):
                        base_station = BaseStationInformation()
                        #get country
                        line = line = scan_process.stdout.readline()
                        match = re.search(r'country\s(\w+)',line)
                        if match:
                            base_station.country = match.group(1)
                        #get provider
                        line = line = scan_process.stdout.readline()
                        match = re.search(r'provider\s(.+)',line)
                        if match:
                            base_station.provider = match.group(1)
                        #get arfcn
                        line = line = scan_process.stdout.readline()
                        match = re.search(r'arfcn\s(\d+)',line)
                        if match:
                            base_station.arfcn = match.group(1)
                        #get rxlev
                        line = line = scan_process.stdout.readline()
                        match = re.search(r'rxlev\s(.\d+)',line)
                        if match:
                            base_station.rxlev = match.group(1)
                        #get neighbours
                        line = line = scan_process.stdout.readline()
                        match = re.search(r'si2\s(.+)',line)
                        if match:
                            base_station.neighbours = match.group(1).split(' ')
                        #endinfo
                        line = line = scan_process.stdout.readline()
                        
                        self._base_station_found_callback(base_station)
            print 'killing scan'
            scan_process.kill()
    